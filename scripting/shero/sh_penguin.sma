// PENGUIN! - From Batman. Oswald Chesterfield Cobblepot, is a "reformed" master criminal.

/*****AMX Mod X ONLY! Requires Fakemeta module*****/

/* CVARS - copy and paste to shconfig.cfg

//Penguin
penguin_level 0
penguin_grenademult 1.0		//Damage multiplyer, 1.0 = no xtra dmg (def 1.0)
penguin_grenadetimer 30.0	//How many seconds delay for new grenade after nade is thrown (def 30.0)
penguin_cooldown 120.0		//How many seconds until penguin grenade can be used again (def 120.0)
penguin_fuse 5.0			//Length of time Penguin grenades can seek for before blowing up (def 5.0)
penguin_nadespeed 900		//Speed of Penguin grenades when seeking (def 900)

*/

/*
* v1.2 - vittu - 9/28/05
*      - Minor code clean up and changes.
*      - Fixed getting actual grenade id.
*      - Fixed pausing of grenade blowing up used for fuse cvar.
*      - Fixed grenade touching to only explode on enemy contact.
*      - Added view model, so you know when you have a penguin nade.
*      - Made a hack job, so multiplier/cooldown will work if nade is paused
*          past when nades are supposed to blow. This will likely have bugs.
*
*    Based on AMXX Heatseeking Hegrenade 1.3 by Cheap_Suit.
*    HE Grenade Model by Opposing Forces Team, xinsomniacboix, Indolence, & haZaa.
*   	Yang wrote, "Cred goez to vittu's sexiness on gambit and cheap_suit who created the original plugin".
*/

#include <superheromod>

#define AMMOX_HEGRENADE 12
#define DMG_GRENADE (1<<24)

#define fm_find_ent_by_class(%1,%2) engfunc(EngFunc_FindEntityByString, %1, "classname", %2)

// GLOBAL VARIABLES
new gHeroID
new const gHeroName[] = "Penguin"
new bool:gHasPenguinPower[SH_MAXSLOTS+1]
new bool:gPauseEntity[999]
new bool:gPenguinNade[SH_MAXSLOTS+1][999]
new Float:gNadeSpeed
new bool:gCZBotRegisterHam
new gPcvarGrenadeMult, gPcvarGrenadeTimer, gPcvarCooldown, gPcvarFuse, gPcvarNadeSpeed
new bot_quota
new gSpriteTrail
new const gModel_W_HEGrenade[] = "models/shmod/penguin_w_hegrenade.mdl"
new const gModel_V_HEGrenade[] = "models/shmod/penguin_v_hegrenade.mdl"
//----------------------------------------------------------------------------------------------
public plugin_init() {
	// Plugin Info
	register_plugin("SUPERHERO Penguin", "1.3", "Yang/vittu")
	
	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	new pcvarLevel = register_cvar("penguin_level", "0")
	gPcvarGrenadeMult = register_cvar("penguin_grenademult", "1.0")
	gPcvarGrenadeTimer = register_cvar("penguin_grenadetimer", "30.0")
	gPcvarCooldown = register_cvar("penguin_cooldown", "120.0")
	gPcvarFuse = register_cvar("penguin_fuse", "5.0")
	gPcvarNadeSpeed = register_cvar("penguin_nadespeed", "900")
	
	// FIRE THE EVENTS TO CREATE THIS SUPERHERO!
	gHeroID = sh_create_hero(gHeroName, pcvarLevel)
	sh_set_hero_info(gHeroID, "Seeking HE-Penguins", "Throw HE Grenade strapped Pengiun friends that Seek out your enemy, also refill HE Grenades.")
	
	// REGISTER EVENTS THIS HERO WILL RESPOND TO!
	RegisterHam(Ham_TakeDamage, "player", "fw_Player_TakeDamage_Pre")
	register_forward(FM_SetModel, "fw_SetModel")
	register_forward(FM_Think, "fw_Think")
	register_forward(FM_Touch, "fw_Touch")
	register_event("CurWeapon", "weapon_change", "be", "1=1")
	register_event("AmmoX", "grenade_refill", "b")
	
	bot_quota = get_cvar_pointer("bot_quota")
}
//----------------------------------------------------------------------------------------------
public plugin_precache() {
	gSpriteTrail = precache_model("sprites/smoke.spr")
	precache_model(gModel_W_HEGrenade)
	precache_model(gModel_V_HEGrenade)
}
//----------------------------------------------------------------------------------------------
public sh_hero_init(id, heroID, mode) {
	if(gHeroID != heroID) return
	
	if(is_user_alive(id) && mode == SH_HERO_ADD) {
		penguin_weapons(id)
		
		if(get_user_weapon(id) == CSW_HEGRENADE) switch_model(id)
	}
	
	gHasPenguinPower[id] = mode ? true : false
	
	sh_debug_message(id, 1, "%s %s", gHeroName, mode ? "ADDED" : "DROPPED")
}
//----------------------------------------------------------------------------------------------
public sh_client_spawn(id) {
	if(!gHasPenguinPower[id]) return
	
	gPlayerInCooldown[id] = false
	set_task(0.1, "penguin_weapons", id)
	
	for(new i = SH_MAXSLOTS+1; i < charsmax(gPauseEntity); i++) {
		gPenguinNade[id][i] = false
	}
}
//----------------------------------------------------------------------------------------------
public penguin_weapons(id) {
	sh_give_weapon(id, CSW_HEGRENADE)
}
//----------------------------------------------------------------------------------------------
public sh_round_start() {
	for(new i = SH_MAXSLOTS+1; i < charsmax(gPauseEntity); i++) {
		gPauseEntity[i] = false
	}
}
//----------------------------------------------------------------------------------------------
public client_putinserver(id) {
	if(id < 1 || id > sh_maxplayers()) return
	
	if(pev(id, pev_flags) & FL_FAKECLIENT && get_pcvar_num(bot_quota) > 0 && !gCZBotRegisterHam) {
		set_task(0.1, "czbotHookHam", id)
	}
}
//----------------------------------------------------------------------------------------------
public czbotHookHam(id) {
	if(gCZBotRegisterHam || !is_user_connected(id)) return
	
	if(pev(id, pev_flags) & FL_FAKECLIENT && get_pcvar_num(bot_quota) > 0) {
		RegisterHamFromEntity(Ham_TakeDamage, id, "fw_Player_TakeDamage_Pre")
		
		gCZBotRegisterHam = true
	}
}
//----------------------------------------------------------------------------------------------
public fw_Player_TakeDamage_Pre(victim, inflictor, attacker, Float:damage, damagebits) {
	if(!sh_is_active() || !is_user_connected(attacker)) return HAM_IGNORED
	
	if(!gHasPenguinPower[attacker] || gPlayerInCooldown[attacker]) return HAM_IGNORED
	
	if(!(damagebits & DMG_GRENADE)) return HAM_IGNORED
	
	SetHamParamFloat(4, damage *= get_pcvar_float(gPcvarGrenadeMult))
	
	for(new i = SH_MAXSLOTS+1; i < charsmax(gPauseEntity); i++) {
		if(gPenguinNade[attacker][i]) {
			new parm[2]
			parm[0] = i
			parm[1] = attacker
			
			set_task(0.2, "set_cooldown", 0, parm, 2)
		}
	}
	return HAM_IGNORED
}
//----------------------------------------------------------------------------------------------
public set_cooldown(parm[]) {
	new grenadeID = parm[0]
	new grenadeOwner = parm[1]
	
	gPenguinNade[grenadeOwner][grenadeID] = false
	
	if(!is_user_alive(grenadeOwner) || gPlayerInCooldown[grenadeOwner]) return
	
	new Float:penguinCooldown = get_pcvar_float(gPcvarCooldown)
	if(penguinCooldown > 0.0) sh_set_cooldown(grenadeOwner, penguinCooldown)
}
//----------------------------------------------------------------------------------------------
public fw_SetModel(ent, const model[]) {
	if(!sh_is_active()) return FMRES_IGNORED
	
	if(!equal(model, "models/w_hegrenade.mdl")) return FMRES_IGNORED
	
	static Float:dmgtime
	pev(ent, pev_dmgtime, dmgtime)
	
	if(dmgtime == 0.0) return FMRES_IGNORED
	
	new owner = pev(ent, pev_owner)
	
	if(!is_user_alive(owner) || !gHasPenguinPower[owner]) return FMRES_IGNORED
	
	if(!gPlayerInCooldown[owner]) {
		engfunc(EngFunc_SetModel, ent, gModel_W_HEGrenade)
		
		gNadeSpeed = floatclamp(get_pcvar_float(gPcvarNadeSpeed), 1.0, 2000.0)
		gPauseEntity[ent] = true
		
		new parm[3]
		parm[0] = ent
		parm[1] = owner
		// If this changes so must nade_reset time or cooldown may not be set
		// The longer the nade_rest time the more chance for error with attacker identity
		set_task(1.0, "find_target", 0, parm, 3)
		
		set_task(get_pcvar_float(gPcvarFuse), "unpause_nade", ent, parm, 2)
		return FMRES_SUPERCEDE
	}
	return FMRES_IGNORED
}
//----------------------------------------------------------------------------------------------
public find_target(parm[]) {
	new grenadeID = parm[0]
	new grenadeOwner = parm[1]
	
	if(!pev_valid(grenadeID)) return
	
	new Float:shortestDistance = 9999.0, Float:distance, Float:playerOrigin[3], Float:grenadeOrigin[3], nearestPlayer = 0
	new players[SH_MAXSLOTS], playerCount, player, i, rgb[3], CsTeams:userTeam = cs_get_user_team(grenadeOwner)
	
	switch(userTeam) {
		case CS_TEAM_CT: rgb = {50, 50, 175}
		case CS_TEAM_T: rgb = {175, 50, 50}
		default: rgb = {175, 175, 175}
	}
	
	pev(grenadeID, pev_origin, grenadeOrigin)
	
	get_players(players, playerCount, "a")
	
	for(i = 0; i < playerCount; i++) {
		player = players[i]
		
		if(player < 1 || player > sh_maxplayers() || cs_get_user_team(player) == userTeam) continue
		
		pev(player, pev_origin, playerOrigin)
		distance = get_distance_f(playerOrigin, grenadeOrigin)
		
		if(distance <= shortestDistance) {
			shortestDistance = distance
			nearestPlayer = player
		}
	}
	
	if(nearestPlayer > 0.0) {
		// Trail on grenade
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
		write_byte(22) // TE_BEAMFOLLOW
		write_short(grenadeID) // entity:attachment to follow
		write_short(gSpriteTrail) // sprite index
		write_byte(10) // life in 0.1's
		write_byte(3) // line width in 0.1's
		write_byte(rgb[0]) // r
		write_byte(rgb[1]) // g
		write_byte(rgb[2]) // b
		switch(random_num(0,2)) {
			case 0: write_byte(64) // brightness
			case 1: write_byte(128)
			case 2: write_byte(192)
		}
		message_end()
		
		parm[2] = nearestPlayer
		set_task(0.1, "seek_target", grenadeID+1099, parm, 3, "b")
	}
}
//----------------------------------------------------------------------------------------------
public seek_target(parm[]) {
	new grenade = parm[0]
	new target = parm[2]
	
	if(!pev_valid(grenade)) {
		remove_task(grenade+1099)
		return
	}
	
	if(is_user_alive(target)) {
		fm_entity_set_follow(grenade, target)
	}
	else {
		remove_task(grenade+1099)
		
		// Stop the Trail
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
		write_byte(99) //TE_KILLBEAM
		write_short(grenade) // entity
		message_end()
		
		set_task(0.1, "find_target", 0, parm, 3)
	}
}
//----------------------------------------------------------------------------------------------
public unpause_nade(parm[]) {
	new grenadeID = parm[0]
	new grenadeOwner = parm[1]
	
	remove_task(grenadeID)
	
	gPenguinNade[grenadeOwner][grenadeID] = true
	set_task(0.4, "nade_reset", 0, parm, 2)
	
	gPauseEntity[grenadeID] = false
}
//----------------------------------------------------------------------------------------------
public fw_Think(ent) {
	if(ent <= SH_MAXSLOTS || ent > charsmax(gPauseEntity)) return FMRES_IGNORED
	
	if(gPauseEntity[ent]) {
		new Float:nextThink
		pev(ent, pev_nextthink, nextThink)
		set_pev(ent, pev_nextthink, nextThink + 0.1)
		return FMRES_SUPERCEDE
	}
	return FMRES_IGNORED
}
//----------------------------------------------------------------------------------------------
public fw_Touch(ptr, ptd) {
	if(ptr <= SH_MAXSLOTS || ptr > charsmax(gPauseEntity)) return FMRES_IGNORED
	
	if(!pev_valid(ptr) || !pev_valid(ptd)) return FMRES_IGNORED
	
	new classNamePtr[32], classNamePtd[32]
	pev(ptr, pev_classname, classNamePtr, charsmax(classNamePtr))
	pev(ptd, pev_classname, classNamePtd, charsmax(classNamePtd))
	
	if(!equal(classNamePtr, "grenade") || !equal(classNamePtd, "player")) return FMRES_IGNORED
	if(!gPauseEntity[ptr]) return FMRES_IGNORED
	
	if(!is_user_connected(ptd)) return FMRES_IGNORED
	
	new grenadeOwner = pev(ptr, pev_owner)
	
	if(cs_get_user_team(grenadeOwner) == cs_get_user_team(ptd)) return FMRES_IGNORED
	
	new parm[2]
	parm[0] = ptr
	parm[1] = grenadeOwner
	unpause_nade(parm)
	return FMRES_IGNORED
}
//----------------------------------------------------------------------------------------------
public nade_reset(parm[]) {
	new grenadeID = parm[0]
	new grenadeOwner = parm[1]
	
	gPenguinNade[grenadeOwner][grenadeID] = false
}
//----------------------------------------------------------------------------------------------
public weapon_change(id) {
	if(!sh_is_active() || !gHasPenguinPower[id]) return
	
	if(read_data(2) != CSW_HEGRENADE) return
	
	switch_model(id)
}
//----------------------------------------------------------------------------------------------
switch_model(id) {
	if(!sh_is_active() || !is_user_alive(id) || gPlayerInCooldown[id]) return
	
	if(cs_get_user_shield(id)) return
	
	set_pev(id, pev_viewmodel2, gModel_V_HEGrenade)
}
//----------------------------------------------------------------------------------------------
public grenade_refill(id) {
	if(!sh_is_active() || !is_user_alive(id) || !gHasPenguinPower[id]) return
	
	new ammoType = read_data(1), ammoCount = read_data(2)
	
	if(ammoType == AMMOX_HEGRENADE) {
		if(ammoCount == 0) {
			set_task(get_pcvar_float(gPcvarGrenadeTimer), "penguin_weapons", id)
		}
		else if(ammoCount > 0) {
			remove_task(id)
		}
	}
}
//----------------------------------------------------------------------------------------------
fm_entity_set_follow(entity, target) {
	if(!pev_valid(entity) || !is_user_alive(target)) return false
	
	new Float:targetOrigin[3], Float:entityOrigin[3]
	pev(target, pev_origin, targetOrigin)
	pev(entity, pev_origin, entityOrigin)
	
	new Float:invTime = (gNadeSpeed / vector_distance(targetOrigin, entityOrigin))
	
	new Float:distance[3]
	distance[0] = targetOrigin[0] - entityOrigin[0]
	distance[1] = targetOrigin[1] - entityOrigin[1]
	distance[2] = targetOrigin[2] - entityOrigin[2]
	
	new Float:velocity[3]
	velocity[0] = distance[0] * invTime
	velocity[1] = distance[1] * invTime
	velocity[2] = distance[2] * invTime
	
	set_pev(entity, pev_velocity, velocity)
	
	new Float:angle[3]
	vector_to_angle(velocity, angle)
	set_pev(entity, pev_angles, angle)
	
	return true
}
//----------------------------------------------------------------------------------------------